import cv2
import numpy as np
from config import WINDOW_WIDTH, WINDOW_HEIGHT


# Transform/Fit aruco markers then warp
def performPerspectiveWarp(frame, corners):
    arucoCorners = getFittingArucoCorners(
        [corners[0][0], corners[1][0], corners[2][0], corners[3][0]])
    return perspectiveWarp(frame, arucoCorners)


def getFittingArucoCorners(markerCorners):
    centers = []
    # get center of all markers and sort them
    for corners in markerCorners:
        # find center
        # https://stackoverflow.com/questions/4355894/how-to-get-center-of-set-of-points-using-python
        x, y = zip(*corners)
        center = (max(x) + min(x)) / 2., (max(y) + min(y)) / 2.
        centers.append(center)
    sortedCenters = sortPoints(centers)

    correctlySortedMarkers = []

    # sort original array to always have the same order
    for x in range(4):
        for y in range(4):
            if centers[y] == sortedCenters[x]:
                correctlySortedMarkers.append(markerCorners[y])
    return [correctlySortedMarkers[0][3], correctlySortedMarkers[1][2],
            correctlySortedMarkers[2][1], correctlySortedMarkers[3][0]]


# Solution generated by ChatGPT
def sortPoints(arr):
    # Seperate Array by the two points most left and most right
    left_points = sorted(arr, key=lambda x: x[0])[:2]
    right_points = sorted(arr, key=lambda x: x[0])[2:]

    top_left = min(left_points, key=lambda x: x[1])
    bottom_left = max(left_points, key=lambda x: x[1])

    top_right = min(right_points, key=lambda x: x[1])
    bottom_right = max(right_points, key=lambda x: x[1])

    return [top_left, bottom_left, bottom_right, top_right]


# Solution in parts from https://theailearner.com/tag/cv2-warpperspective/
def perspectiveWarp(img, cornersrect):
    a = 0
    b = 1
    c = 2
    d = 3

    pt_a = [cornersrect[a][0], cornersrect[a][1]]
    pt_b = [cornersrect[b][0], cornersrect[b][1]]
    pt_c = [cornersrect[c][0], cornersrect[c][1]]
    pt_d = [cornersrect[d][0], cornersrect[d][1]]

    input_pts = np.float32([pt_a, pt_b, pt_c, pt_d])
    output_pts = np.float32([[0, 0],
                             [0, WINDOW_HEIGHT - 1],
                             [WINDOW_WIDTH - 1, WINDOW_HEIGHT - 1],
                             [WINDOW_WIDTH - 1, 0]])

    m = cv2.getPerspectiveTransform(input_pts, output_pts)
    out = cv2.warpPerspective(img, m, (WINDOW_WIDTH, WINDOW_HEIGHT),
                              flags=cv2.INTER_LINEAR)
    return out
