import argparse
import copy
import os
import numpy as np
import cv2
import math
import sys

WINDOW_NAME = 'Image Extractor'

# command line arguments
parser = argparse.ArgumentParser(description="Process image")
parser.add_argument('--image', help="Path to image file")
parser.add_argument('--output', help="Path to output destination")
# height and image for resolution
parser.add_argument('--height', help="height of saved image")
parser.add_argument('--width', help="width of saved image")

args = parser.parse_args()
image = cv2.imread(os.path.normpath(args.image))
path = os.path.normpath(args.output)
savedImageHeight = int(args.height)
savedImageWidth = int(args.width)

cv2.namedWindow(WINDOW_NAME)


class ImageResizer:

    def __init__(self, initialImage):
        self.selectedPoints = []
        self.initialImage = copy.deepcopy(initialImage)
        self.currentImage = copy.deepcopy(initialImage)
        self.resultView = False

    # handles the logic for the 4 points
    def handleAddPoint(self, x, y):
        if not self.resultView:
            if len(self.selectedPoints) <= 2:
                self.selectedPoints.append([x, y])
                self.currentImage = cv2.circle(self.currentImage, (x, y), 5,
                                               (255, 0, 0), -1)
                cv2.imshow(WINDOW_NAME, self.currentImage)
            elif len(self.selectedPoints) == 3:
                self.selectedPoints.append([x, y])
                self.selectedPoints = sortPoints(self.selectedPoints)
                self.currentImage = perspectiveWarp(self.initialImage,
                                                    self.selectedPoints)
                self.selectedPoints = []
                cv2.imshow(WINDOW_NAME, self.currentImage)
                self.resultView = True

    def resetImage(self):
        self.currentImage = copy.deepcopy(self.initialImage)
        self.selectedPoints = []
        self.resultView = False
        cv2.imshow(WINDOW_NAME, self.currentImage)

    def saveImage(self):
        cv2.imwrite(path, self.currentImage)


# Solution generated by ChatGPT
# Orders the 4 Points in clock-wise rotation starting from top left
def sortPoints(arr):
    # Separate Array by the two points most left and most right
    left_points = sorted(arr, key=lambda x: x[0])[:2]
    right_points = sorted(arr, key=lambda x: x[0])[2:]

    top_left = min(left_points, key=lambda x: x[1])
    bottom_left = max(left_points, key=lambda x: x[1])

    top_right = min(right_points, key=lambda x: x[1])
    bottom_right = max(right_points, key=lambda x: x[1])

    return [top_left, bottom_left, bottom_right, top_right]


# Solution in parts from https://theailearner.com/tag/cv2-warpperspective/
def perspectiveWarp(img, cornersrect):
    a = 0
    b = 1
    c = 2
    d = 3

    pt_a = [cornersrect[a][0] - 10, cornersrect[a][1] - 10]
    pt_b = [cornersrect[b][0] - 10, cornersrect[b][1] + 10]
    pt_c = [cornersrect[c][0] + 10, cornersrect[c][1] + 10]
    pt_d = [cornersrect[d][0] + 10, cornersrect[d][1] - 10]

    input_pts = np.float32([pt_a, pt_b, pt_c, pt_d])
    output_pts = np.float32([[0, 0],
                             [0, savedImageHeight - 1],
                             [savedImageWidth - 1, savedImageHeight - 1],
                             [savedImageWidth - 1, 0]])

    m = cv2.getPerspectiveTransform(input_pts, output_pts)
    out = cv2.warpPerspective(img, m, (savedImageWidth, savedImageHeight),
                              flags=cv2.INTER_LINEAR)
    return out


imageResizer = ImageResizer(image)


def mouse_callback(event, x, y, flags, param):
    if event == cv2.EVENT_LBUTTONDOWN:
        imageResizer.handleAddPoint(x, y)


cv2.setMouseCallback(WINDOW_NAME, mouse_callback)

while True:
    cv2.imshow(WINDOW_NAME, imageResizer.currentImage)

    k = cv2.waitKey(0)

    if k == 27:
        imageResizer.resetImage()
    elif k == ord('s'):
        imageResizer.saveImage()
        break
    elif k == ord('q'):
        break

cv2.destroyAllWindows()
